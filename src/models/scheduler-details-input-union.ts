/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";

/**
 * The spot scaler manages all compute in this capacity within its management window, including compute procured from manual orders. If existing reservations exceed the desired quantity the spot scaler will attempt to sell the excess. If existing reservations are below the desired quantity the spot scaler will attempt to buy in order to reach the target.
 */
export type SchedulerDetailsSpotScalerInput = {
  /**
   * Target node count.
   */
  desiredQuantity: number;
  /**
   * How far ahead (in minutes) the spot scaler buys and sells compute. Higher values secure compute further in advance but commit to longer windows that may need to be sold when scaling down, potentially at a loss. Lower values reduce waste but risk compute being unavailable. Orders are placed in 1-hour blocks, so the furthest hour is secured up to `managed_window_minutes - 60` minutes before it begins.
   */
  managedWindowMinutes: number;
  /**
   * Price rate in dollars per node-hour.
   */
  minSellPriceDollarsPerNodeHour: string;
  /**
   * Price rate in dollars per node-hour.
   */
  maxBuyPriceDollarsPerNodeHour: string;
  /**
   * Enable/disable the spot scaler. Disabling cancels all standing orders.
   */
  enabled: boolean;
};

/**
 * Schedulers automatically place buy and sell orders to attempt to achieve desired compute availability.
 */
export type SchedulerDetailsInputUnion = SchedulerDetailsSpotScalerInput;

/** @internal */
export type SchedulerDetailsSpotScalerInput$Outbound = {
  desired_quantity: number;
  managed_window_minutes: number;
  min_sell_price_dollars_per_node_hour: string;
  max_buy_price_dollars_per_node_hour: string;
  enabled: boolean;
};

/** @internal */
export const SchedulerDetailsSpotScalerInput$outboundSchema: z.ZodMiniType<
  SchedulerDetailsSpotScalerInput$Outbound,
  SchedulerDetailsSpotScalerInput
> = z.pipe(
  z.object({
    desiredQuantity: z.int(),
    managedWindowMinutes: z.int(),
    minSellPriceDollarsPerNodeHour: z.string(),
    maxBuyPriceDollarsPerNodeHour: z.string(),
    enabled: z.boolean(),
  }),
  z.transform((v) => {
    return remap$(v, {
      desiredQuantity: "desired_quantity",
      managedWindowMinutes: "managed_window_minutes",
      minSellPriceDollarsPerNodeHour: "min_sell_price_dollars_per_node_hour",
      maxBuyPriceDollarsPerNodeHour: "max_buy_price_dollars_per_node_hour",
    });
  }),
);

export function schedulerDetailsSpotScalerInputToJSON(
  schedulerDetailsSpotScalerInput: SchedulerDetailsSpotScalerInput,
): string {
  return JSON.stringify(
    SchedulerDetailsSpotScalerInput$outboundSchema.parse(
      schedulerDetailsSpotScalerInput,
    ),
  );
}

/** @internal */
export type SchedulerDetailsInputUnion$Outbound =
  SchedulerDetailsSpotScalerInput$Outbound;

/** @internal */
export const SchedulerDetailsInputUnion$outboundSchema: z.ZodMiniType<
  SchedulerDetailsInputUnion$Outbound,
  SchedulerDetailsInputUnion
> = z.lazy(() => SchedulerDetailsSpotScalerInput$outboundSchema);

export function schedulerDetailsInputUnionToJSON(
  schedulerDetailsInputUnion: SchedulerDetailsInputUnion,
): string {
  return JSON.stringify(
    SchedulerDetailsInputUnion$outboundSchema.parse(schedulerDetailsInputUnion),
  );
}
