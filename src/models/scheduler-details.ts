/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";

export const SchedulerDetailsType = {
  SpotScaler: "spot_scaler",
} as const;
export type SchedulerDetailsType = ClosedEnum<typeof SchedulerDetailsType>;

/**
 * The spot scaler manages all compute in this capacity within its management window,
 *
 * @remarks
 * including compute procured from manual orders. If existing
 * reservations exceed the desired quantity the spot scaler will attempt to
 * sell the excess. If existing reservations are below the desired quantity the
 * spot scaler will attempt to buy in order to reach the target.
 */
export type SchedulerDetailsSpotScaler = {
  /**
   * Target node count.
   */
  desiredQuantity: number;
  /**
   * How far ahead (in minutes) the spot scaler buys and sells compute. Higher
   *
   * @remarks
   * values secure compute further in advance but commit to longer windows
   * that may need to be sold when scaling down, potentially at a loss.
   * Lower values reduce waste but risk compute being unavailable. Orders
   * are placed in 1-hour blocks, so the furthest hour is secured up to
   * `managed_window_minutes - 60` minutes before it begins.
   */
  managedWindowMinutes: number;
  /**
   * Price rate in dollars per node-hour.
   */
  minSellPriceDollarsPerNodeHour: string;
  /**
   * Price rate in dollars per node-hour.
   */
  maxBuyPriceDollarsPerNodeHour: string;
  /**
   * Enable/disable the spot scaler. Disabling cancels all standing orders.
   */
  enabled: boolean;
  type: SchedulerDetailsType;
};

/**
 * Schedulers automatically place buy and sell orders to
 *
 * @remarks
 * attempt to achieve desired compute availability.
 */
export type SchedulerDetails = SchedulerDetailsSpotScaler;

/** @internal */
export const SchedulerDetailsType$inboundSchema: z.ZodMiniEnum<
  typeof SchedulerDetailsType
> = z.enum(SchedulerDetailsType);
/** @internal */
export const SchedulerDetailsType$outboundSchema: z.ZodMiniEnum<
  typeof SchedulerDetailsType
> = SchedulerDetailsType$inboundSchema;

/** @internal */
export const SchedulerDetailsSpotScaler$inboundSchema: z.ZodMiniType<
  SchedulerDetailsSpotScaler,
  unknown
> = z.pipe(
  z.object({
    desired_quantity: types.number(),
    managed_window_minutes: types.number(),
    min_sell_price_dollars_per_node_hour: types.string(),
    max_buy_price_dollars_per_node_hour: types.string(),
    enabled: types.boolean(),
    type: SchedulerDetailsType$inboundSchema,
  }),
  z.transform((v) => {
    return remap$(v, {
      "desired_quantity": "desiredQuantity",
      "managed_window_minutes": "managedWindowMinutes",
      "min_sell_price_dollars_per_node_hour": "minSellPriceDollarsPerNodeHour",
      "max_buy_price_dollars_per_node_hour": "maxBuyPriceDollarsPerNodeHour",
    });
  }),
);
/** @internal */
export type SchedulerDetailsSpotScaler$Outbound = {
  desired_quantity: number;
  managed_window_minutes: number;
  min_sell_price_dollars_per_node_hour: string;
  max_buy_price_dollars_per_node_hour: string;
  enabled: boolean;
  type: string;
};

/** @internal */
export const SchedulerDetailsSpotScaler$outboundSchema: z.ZodMiniType<
  SchedulerDetailsSpotScaler$Outbound,
  SchedulerDetailsSpotScaler
> = z.pipe(
  z.object({
    desiredQuantity: z.int(),
    managedWindowMinutes: z.int(),
    minSellPriceDollarsPerNodeHour: z.string(),
    maxBuyPriceDollarsPerNodeHour: z.string(),
    enabled: z.boolean(),
    type: SchedulerDetailsType$outboundSchema,
  }),
  z.transform((v) => {
    return remap$(v, {
      desiredQuantity: "desired_quantity",
      managedWindowMinutes: "managed_window_minutes",
      minSellPriceDollarsPerNodeHour: "min_sell_price_dollars_per_node_hour",
      maxBuyPriceDollarsPerNodeHour: "max_buy_price_dollars_per_node_hour",
    });
  }),
);

export function schedulerDetailsSpotScalerToJSON(
  schedulerDetailsSpotScaler: SchedulerDetailsSpotScaler,
): string {
  return JSON.stringify(
    SchedulerDetailsSpotScaler$outboundSchema.parse(schedulerDetailsSpotScaler),
  );
}
export function schedulerDetailsSpotScalerFromJSON(
  jsonString: string,
): SafeParseResult<SchedulerDetailsSpotScaler, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SchedulerDetailsSpotScaler$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SchedulerDetailsSpotScaler' from JSON`,
  );
}

/** @internal */
export const SchedulerDetails$inboundSchema: z.ZodMiniType<
  SchedulerDetails,
  unknown
> = z.lazy(() => SchedulerDetailsSpotScaler$inboundSchema);
/** @internal */
export type SchedulerDetails$Outbound = SchedulerDetailsSpotScaler$Outbound;

/** @internal */
export const SchedulerDetails$outboundSchema: z.ZodMiniType<
  SchedulerDetails$Outbound,
  SchedulerDetails
> = z.lazy(() => SchedulerDetailsSpotScaler$outboundSchema);

export function schedulerDetailsToJSON(
  schedulerDetails: SchedulerDetails,
): string {
  return JSON.stringify(
    SchedulerDetails$outboundSchema.parse(schedulerDetails),
  );
}
export function schedulerDetailsFromJSON(
  jsonString: string,
): SafeParseResult<SchedulerDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SchedulerDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SchedulerDetails' from JSON`,
  );
}
