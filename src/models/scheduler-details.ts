/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";

/**
 * The spot scaler manages all compute in this capacity within its management window, including compute procured from manual orders. If existing reservations exceed the desired quantity the spot scaler will attempt to sell the excess. If existing reservations are below the desired quantity the spot scaler will attempt to buy in order to reach the target.
 */
export type SchedulerDetailsSpotScaler = {
  /**
   * Target node count.
   */
  desiredQuantity: number;
  /**
   * How far ahead (in minutes) the spot scaler buys and sells compute. Higher values secure compute further in advance but commit to longer windows that may need to be sold when scaling down, potentially at a loss. Lower values reduce waste but risk compute being unavailable. Orders are placed in 1-hour blocks, so the furthest hour is secured up to `managed_window_minutes - 60` minutes before it begins.
   */
  managedWindowMinutes: number;
  /**
   * Price rate in dollars per node-hour.
   */
  minSellPriceDollarsPerNodeHour: string;
  /**
   * Price rate in dollars per node-hour.
   */
  maxBuyPriceDollarsPerNodeHour: string;
  /**
   * Enable/disable the spot scaler. Disabling cancels all standing orders.
   */
  enabled: boolean;
  type: "spot_scaler";
};

/**
 * Schedulers automatically place buy and sell orders to attempt to achieve desired compute availability.
 */
export type SchedulerDetails = SchedulerDetailsSpotScaler;

/** @internal */
export const SchedulerDetailsSpotScaler$inboundSchema: z.ZodMiniType<
  SchedulerDetailsSpotScaler,
  unknown
> = z.pipe(
  z.object({
    desired_quantity: types.number(),
    managed_window_minutes: types.number(),
    min_sell_price_dollars_per_node_hour: types.string(),
    max_buy_price_dollars_per_node_hour: types.string(),
    enabled: types.boolean(),
    type: z._default(types.literal("spot_scaler"), "spot_scaler"),
  }),
  z.transform((v) => {
    return remap$(v, {
      "desired_quantity": "desiredQuantity",
      "managed_window_minutes": "managedWindowMinutes",
      "min_sell_price_dollars_per_node_hour": "minSellPriceDollarsPerNodeHour",
      "max_buy_price_dollars_per_node_hour": "maxBuyPriceDollarsPerNodeHour",
    });
  }),
);

export function schedulerDetailsSpotScalerFromJSON(
  jsonString: string,
): SafeParseResult<SchedulerDetailsSpotScaler, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SchedulerDetailsSpotScaler$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SchedulerDetailsSpotScaler' from JSON`,
  );
}

/** @internal */
export const SchedulerDetails$inboundSchema: z.ZodMiniType<
  SchedulerDetails,
  unknown
> = z.lazy(() => SchedulerDetailsSpotScaler$inboundSchema);

export function schedulerDetailsFromJSON(
  jsonString: string,
): SafeParseResult<SchedulerDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SchedulerDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SchedulerDetails' from JSON`,
  );
}
