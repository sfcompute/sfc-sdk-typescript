/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";
import { Side, Side$inboundSchema } from "./side.js";
import {
  V2OrderStatus,
  V2OrderStatus$inboundSchema,
} from "./v2-order-status.js";

export type V2OrderResponse = {
  object: "order";
  id: string;
  capacity: string;
  side: Side;
  /**
   * If true, the order stays in the order book until either fills, is explicitly cancelled, or the order end time is reached resulting in automatic cancellation. If false, the order is cancelled immediately if it doesn't fill.
   */
  allowStanding: boolean;
  /**
   * Datacenter locations this order can fill in (derived from target capacity at order creation by default).
   */
  zones: Array<string>;
  /**
   * Number of nodes requested to be reserved or released between `start_at` and `end_at`.
   */
  nodeCount: number;
  /**
   * Unix timestamp.
   */
  startAt: number;
  /**
   * Unix timestamp.
   */
  endAt: number;
  /**
   * Price rate in dollars per node-hour.
   */
  limitPriceDollarsPerNodeHour: string;
  /**
   * `pending` = not resolved/processed yet.
   *
   * @remarks
   * `filled` = order executed.
   * `standing` = the order is waiting for a match.
   * `cancelled` = the order was cancelled either automatically (not a standing order and didn't immediately fill, or current time past `end_at`) or by explicit cancellation.
   * `rejected` = validation/system error occurred.
   */
  status: V2OrderStatus;
  /**
   * Unix timestamp.
   */
  createdAt: number;
  /**
   * Unix timestamp.
   */
  filledAt?: number | undefined;
  /**
   * Price rate in dollars per node-hour.
   */
  filledPriceDollarsPerNodeHour?: string | undefined;
  /**
   * Unix timestamp.
   */
  cancelledAt?: number | undefined;
};

/** @internal */
export const V2OrderResponse$inboundSchema: z.ZodMiniType<
  V2OrderResponse,
  unknown
> = z.pipe(
  z.object({
    object: z._default(types.literal("order"), "order"),
    id: types.string(),
    capacity: types.string(),
    side: Side$inboundSchema,
    allow_standing: types.boolean(),
    zones: z.array(types.string()),
    node_count: types.number(),
    start_at: types.number(),
    end_at: types.number(),
    limit_price_dollars_per_node_hour: types.string(),
    status: V2OrderStatus$inboundSchema,
    created_at: types.number(),
    filled_at: types.optional(types.number()),
    filled_price_dollars_per_node_hour: types.optional(types.string()),
    cancelled_at: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "allow_standing": "allowStanding",
      "node_count": "nodeCount",
      "start_at": "startAt",
      "end_at": "endAt",
      "limit_price_dollars_per_node_hour": "limitPriceDollarsPerNodeHour",
      "created_at": "createdAt",
      "filled_at": "filledAt",
      "filled_price_dollars_per_node_hour": "filledPriceDollarsPerNodeHour",
      "cancelled_at": "cancelledAt",
    });
  }),
);

export function v2OrderResponseFromJSON(
  jsonString: string,
): SafeParseResult<V2OrderResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => V2OrderResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'V2OrderResponse' from JSON`,
  );
}
